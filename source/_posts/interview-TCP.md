---
title: 面试题系列之网络协议-TCP
categories: []
tags: [面试题]
comments: false
date: 2019-07-28 14:13:33
img:
---
## TCP协议

### TCP和UDP的区别

> TCP是一个面向连接的、可靠的、基于字节流的传输层协议。
> UDP是一个面向无连接的传输层协议。

TCP的三大核心特性：

* **面向连接**
TCP在客户端和服务器互相通信之前，TCP需要三次握手建立连接
UDP没有相应建立连接的过程。

* **可靠的**
TCP使用校验、确认和重传机制来保证可靠传输；
TCP给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复；
TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
UDP没有这些机制。

* **基于字节流**
TCP是基于字节流传输数据的。
UDP是基于数据报传输数据的。

**注：** TCP并不能保证数据一定会被对方接收到，因为这是不可能的。TCP能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

### TCP三次握手

> 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

![image](/images/tcp_three.png)
刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：

* 第一次握手（SYN=1,seq=x）：
客户端给服务端发送一个含有 SYN=1 和 seq=x（客户端的初始化序列号ISN）的报文段，然后客户端进入 `SYN_SEND` 状态，等待服务端确认。
此报文段不能携带数据，但需要消耗掉一个序号。

* 第二次握手（SYN=1,ACK=1,seq=y,ack=x+1）:
服务端收到客户端的 SYN 报文后，会发送一个含有 SYN=1（服务端以自己的SYN作为应答）、ACK=1（服务端的确认字符）、seq=y（服务端的初始化序列号ISN）和ack=x+1（客户端ISN + 1，表示已经收到了客户端的SYN）的确认报文段给客户端，然后服务端进入`SYN_RCVD`状态。

* 第三次握手(ACK=1,ack=y+1):
客户端收到服务端的 SYN 报文后，会发送一个含有 ACK=1（客户端的确认字符）、seq=x+1（初始为seq=x，第二个报文段所以要+1）和ack=y+1（服务端ISN + 1，表示已经收到了服务端的SYN）的确认报文段给服务器，然后客户端进入`ESTABLISHED`状态，服务端收到 ACK 报文后也进入`ESTABLISHED`状态，此时双方建立连接完成，三次握手结束。
此报文段可以携带数据，不携带数据则不消耗序号。

**注：**

* SYN：（Synchronize Sequence Numbers）同步序列编号，当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。 因此，SYN置1就表示这是一个连接请求或连接接受报文。)
* ACK：（Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。(TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1)
* seq：数据包本身的序列号，初始序列号随机选取。
* ack：期望对方继续发送的那个数据包的序列号，为收到的序列号+1。
* 发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

#### 为什么不是两次或是四次

**两次：** 无法确认客户端的接收能力。

模拟两次握手的场景：

* 客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。
* 后来收到了确认，建立了连接，数据传输完毕后，就释放了连接。
* 但是第一个丢失的报文段只是在某些网络节点长时间滞留，滞留到连接释放以后才到达服务端。
* 服务端误认为是客户端又发出的新请求，于是向客户端发出确认报文段，同意建立连接。
* 但是此时客户端会忽略服务端发来的确认，也不发数据，而服务端还在保持连接等待客户端发送数据，造成了连接资源的浪费。

**四次：** 三次握手已经确认了双方`发送`和`接收`的能力，四次或更多次就用处不大了。
  
#### 三次握手过程中可以携带数据吗

* 如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。

* 第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。
  
#### ISN（Initial Sequence Number）是固定的吗

* 当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。
* ISN可以看作是一个32bit的计算器，每4ms加1。
* ISN随时间而变化，因此每个连接的ISN都是不同的，保证连接的正确性。
* 如果ISN是固定的，攻击者很容易猜出后续的确认号，连接容易遭到攻击。

#### 半连接队列、全连接队列和SYN Flood攻击

> 三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。

**半连接队列：** 当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了半连接队列（SYN Queue）。

**全连接队列：** 当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列（Accept Queue）。

**SYN Flood 攻击原理：**
SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:

* 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
* 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。
  
**如何应对 SYN Flood 攻击？**

1. 增加 SYN 连接，也就是增加半连接队列的容量。
2. 减少 SYN + ACK 重试次数，避免大量的超时重发。
3. 过滤网关防护。
4. 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。

### TCP四次挥手

> 建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务器均可主动发起挥手动作。

![image](/images/tcp_four.png)
刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

* 第一次挥手（FIN=1,seq=p）：
客户端发送一个含有FIN=1和seq=p的**连接释放报文段**，并停止再发送数据，客户端进入`FIN_WAIT1`（终止等待1）状态，等待服务端确认。同时客户端也变成了`half-close(半关闭)`状态（无法向服务端发送报文，只能接收）。

* 第二次挥手（ACK=1,ack=p+1）：
服务端收到FIN后，发送一个含有ACK=1和ack=u+1的**确认报文段**，服务端进入`CLOSE_WAIT`（关闭等待）状态，此时TCP处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后进入`FIN_WAIT2`（终止等待2）状态，等待服务端发出的连接释放报文段。

* 第三次挥手（FIN=1,ACK=1,seq=q,ack=p+1）：
服务端发送一个含有FIN=1、ACK=1、seq=w和ack=u+1的**连接释放报文段**，服务端进入`LAST_ACK`（最后确认）状态，等待客户端确认。

* 第四次挥手（ACK=1,ack=q+1）：
客户端收到FIN后，发送一个含有ACK=1和ack=q+1的**确认报文段**，客户端进入`TIME_WAIT`（时间等待）状态，此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。服务端收到ACK报文后就关闭连接，处于`CLOSED`状态。

**注：** 在2MSL时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。

#### 挥手为什么需要四次而不是三次

* 服务端接收到FIN，往往不会立即返回FIN（需要等服务端所有的报文都发送完毕了，才能发FIN）
* 服务端先发一个ACK表示已经收到客户端的FIN
* 服务端发完所有报文会延迟一段时间才发FIN，所以造成了四次挥手
* 如果三次，这个延迟可能会导致客户端误认为FIN没有到达服务端，从而不断的重发FIN
  
#### 等待2MSL的意义

> MSL(Maximum Segment Lifetime，报文最大生存时间)

**如果不等待**
客户端直接关闭连接，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口被新的连接占用，接收到了无用的数据包，会造成数据混乱。

等待2MSL：

* 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能到达对端
* 1 个 MSL 确保对端如果没有收到ACK，对端重传的 FIN 报文可以到达

### TCP KeepAlive

**背景**
TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制来实现。主流的操作系统基本都在内核里支持了这个特性。

**原理**
隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

**局限**
首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。

不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？
站在应用的角度:

* 7200s 也就是两个小时检测一次，时间太长
* 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

[想要了解更多](http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/)
